const canvas = document.querySelector('canvas');
const score = document.querySelector('#score');
const scoreTop = document.querySelector('#score_top');

scoreTop.textContent = window.localStorage.getItem('best') ? window.localStorage.getItem('best') : 'Aucun';

const ctx = canvas.getContext('2d');
let count = 0;

const width = canvas.width;
const height = canvas.height;

const color = "rgba(255, 255, 255, 0.5)";
const horizontalLines = 20;
const verticalLines = 20;

const drawGrid = () => {
    for (let i = 0; i < horizontalLines; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * height / horizontalLines);
        ctx.lineTo(width, i * height / horizontalLines);
        ctx.strokeStyle = color;
        ctx.stroke();
    }
    for (let i = 0; i < verticalLines; i++) {
        ctx.beginPath();
        ctx.moveTo(i * width / verticalLines, 0);
        ctx.lineTo(i * width / verticalLines, height);
        ctx.strokeStyle = color;
        ctx.stroke();
    }
};

let foodX, foodY;

const randomFood = () => {
    foodX = Math.floor(Math.random() * verticalLines);
    foodY = Math.floor(Math.random() * horizontalLines);
};

let snake = [
    { x: 5, y: 5 },
    { x: 6, y: 5 },
    { x: 7, y: 5 }
];

let dx = 0, dy = 0;

const drawSnake = () => {
    snake.forEach((segment, index) => {
        ctx.fillStyle = index === 0 ? 'rgba(223, 220, 220, 0.79)' : color;
        ctx.fillRect(segment.x * width / verticalLines, segment.y * height / horizontalLines, width / verticalLines, height / horizontalLines);
    });
};

const moveSnake = () => {
    const head = { x: snake[0].x + dx, y: snake[0].y + dy };
    if (snake.some(segment => segment.x === head.x && segment.y === head.y) || head.x < 0 || head.x >= verticalLines || head.y < 0 || head.y >= horizontalLines) {
        const best = window.localStorage.getItem('best');
        if (count > (best ? parseInt(best) : 0)) {
            window.localStorage.setItem('best', count);
        }
        window.location.reload();
        return;
    }
    snake.unshift(head);
    if (head.x === foodX && head.y === foodY) {
        randomFood();
        count++;
        score.textContent = count;
    } else {
        snake.pop();
    }
};

// Fonction heuristique (distance de Manhattan) pour estimer la distance entre deux points
const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.y - b.y);

// Fonction pour obtenir les voisins d'un nœud (les cases adjacentes) tout en filtrant les cases invalides
const getNeighbors = (node) => [
    { x: node.x - 1, y: node.y }, // Voisin à gauche
    { x: node.x + 1, y: node.y }, // Voisin à droite
    { x: node.x, y: node.y - 1 }, // Voisin en haut
    { x: node.x, y: node.y + 1 }  // Voisin en bas
]
.filter(n => 
    n.x >= 0 && n.x < verticalLines && // Vérifie que la case est dans la grille (horizontalement)
    n.y >= 0 && n.y < horizontalLines && // Vérifie que la case est dans la grille (verticalement)
    !snake.some(segment => segment.x === n.x && segment.y === n.y) // Vérifie que la case n'est pas occupée par le serpent
);

// Fonction A* pour trouver le meilleur chemin du serpent vers la nourriture
const aStar = (start, goal) => {
    // Initialisation de l'ensemble ouvert (ensemble des nœuds à explorer), ici commence par le point de départ
    const openSet = [start];
    
    // Dictionnaire qui enregistre les chemins pour revenir en arrière
    const cameFrom = {};
    
    // Dictionnaire qui garde les scores G (le coût pour atteindre chaque point)
    const gScore = { [`${start.x},${start.y}`]: 0 };
    
    // Dictionnaire qui garde les scores F (le coût total estimé pour chaque point)
    const fScore = { [`${start.x},${start.y}`]: heuristic(start, goal) };

    // Tant qu'il y a des nœuds à explorer
    while (openSet.length) {
        // Trier les nœuds dans openSet par fScore (on explore toujours le nœud avec le plus petit fScore)
        openSet.sort((a, b) => fScore[`${a.x},${a.y}`] - fScore[`${b.x},${b.y}`]);
        
        // Prendre le nœud avec le plus petit fScore
        let current = openSet.shift();
        
        // Si le nœud actuel est le but (la nourriture)
        if (current.x === goal.x && current.y === goal.y) {
            // Retrouver le chemin en remontant à partir de l'objectif
            let path = [];
            while (cameFrom[`${current.x},${current.y}`]) {
                path.unshift(current); // Ajouter le nœud à la liste du chemin
                current = cameFrom[`${current.x},${current.y}`]; // Remonter au nœud précédent
            }
            return path; // Retourner le chemin trouvé
        }

        // Explorer les voisins du nœud actuel
        for (let neighbor of getNeighbors(current)) {
            // Calculer le nouveau coût pour atteindre ce voisin
            let tempG = gScore[`${current.x},${current.y}`] + 1;

            // Si ce chemin vers le voisin est plus court que ce qui a été trouvé auparavant
            if (tempG < (gScore[`${neighbor.x},${neighbor.y}`] || Infinity)) {
                // Mettre à jour l'origine de ce voisin
                cameFrom[`${neighbor.x},${neighbor.y}`] = current;
                
                // Mettre à jour le score G pour ce voisin
                gScore[`${neighbor.x},${neighbor.y}`] = tempG;
                
                // Mettre à jour le score F (coût total estimé)
                fScore[`${neighbor.x},${neighbor.y}`] = tempG + heuristic(neighbor, goal);

                // Ajouter ce voisin à l'ensemble ouvert si ce n'est pas déjà fait
                if (!openSet.some(n => n.x === neighbor.x && n.y === neighbor.y)) {
                    openSet.push(neighbor);
                }
            }
        }
    }

    // Si aucun chemin n'a été trouvé, retourner null
    return null;
};

// Fonction pour déplacer l'IA vers la nourriture en utilisant l'algorithme A*
const moveAI = () => {
    // Point de départ (la tête du serpent)
    let start = { x: snake[0].x, y: snake[0].y };

    // Point objectif (la nourriture)
    let goal = { x: foodX, y: foodY };

    // Calculer le chemin avec A* pour aller de la tête du serpent à la nourriture
    let path = aStar(start, goal);

    // Si un chemin est trouvé
    if (path && path.length > 0) {
        // Prendre la première étape du chemin comme le prochain mouvement
        let nextMove = path[0];

        // Mettre à jour la direction du serpent (dx, dy)
        dx = nextMove.x - snake[0].x; // Changement sur l'axe X
        dy = n
    }
}

const main = () => {
    ctx.clearRect(0, 0, width, height);
    drawGrid();
    drawSnake();
    ctx.fillStyle = "rgb(255, 255, 255)";
    ctx.fillRect(foodX * width / verticalLines, foodY * height / horizontalLines, width / verticalLines, height / horizontalLines);
    moveAI();
    moveSnake();
    setTimeout(main, 100);
};

randomFood();
main();
